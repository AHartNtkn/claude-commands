#!/bin/bash
# validate-plan - Validate plan.md format before running claude-plan-issues
#
# This script checks:
# - Plan.md exists and has correct structure
# - All required fields are present
# - IDs are unique and properly formatted
# - References are valid
# - Status values are correct

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Track validation errors
ERRORS=0
WARNINGS=0

# Helper functions
error() {
    echo -e "${RED}ERROR: $1${NC}"
    ERRORS=$((ERRORS + 1))
}

warning() {
    echo -e "${YELLOW}WARNING: $1${NC}"
    WARNINGS=$((WARNINGS + 1))
}

success() {
    echo -e "${GREEN}✓ $1${NC}"
}

# Check if plan.md exists
if [ ! -f ".claude/plan.md" ]; then
    error ".claude/plan.md not found"
    exit 1
fi

echo "Validating .claude/plan.md..."
echo "=========================="

# Extract all task IDs
ALL_TASK_IDS=$(grep -oE 'T-[0-9]+' .claude/plan.md | sort -u)
TASK_COUNT=$(echo "$ALL_TASK_IDS" | wc -l)

success "Found $TASK_COUNT tasks"

# Check for duplicate task IDs
DUPLICATES=$(grep -oE 'T-[0-9]+' .claude/plan.md | sort | uniq -d)
if [ -n "$DUPLICATES" ]; then
    error "Duplicate task IDs found: $DUPLICATES"
fi

# Validate each task
echo -e "\nValidating task structure..."
for TASK_ID in $ALL_TASK_IDS; do
    # Find the task block
    TASK_LINE=$(grep -n "\\* \\*\\*\\[ \\] ${TASK_ID}[: ]" .claude/plan.md | head -1 | cut -d: -f1)
    
    if [ -z "$TASK_LINE" ]; then
        error "Task $TASK_ID referenced but not defined"
        continue
    fi
    
    # Extract task block (from task line to next task or EOF)
    NEXT_TASK_LINE=$(sed -n "$((TASK_LINE + 1)),\$p" .claude/plan.md | grep -n '^\* \*\*\[' | head -1 | cut -d: -f1)
    if [ -n "$NEXT_TASK_LINE" ]; then
        END_LINE=$((TASK_LINE + NEXT_TASK_LINE - 1))
        TASK_BLOCK=$(sed -n "${TASK_LINE},${END_LINE}p" .claude/plan.md)
    else
        TASK_BLOCK=$(sed -n "${TASK_LINE},\$p" .claude/plan.md)
    fi
    
    # Check for required fields
    if ! echo "$TASK_BLOCK" | grep -q '^\* \*\*Status:'; then
        error "Task $TASK_ID missing Status field"
    else
        STATUS=$(echo "$TASK_BLOCK" | grep '^\* \*\*Status:' | sed 's/.*Status:[[:space:]]*//')
        if ! [[ "$STATUS" =~ ^(ready|blocked|analyzed|obsolete)$ ]]; then
            error "Task $TASK_ID has invalid Status: '$STATUS' (must be: ready|blocked|analyzed|obsolete)"
        fi
    fi
    
    if ! echo "$TASK_BLOCK" | grep -q '^\* \*\*Spec Refs:'; then
        warning "Task $TASK_ID missing Spec Refs field"
    fi
    
    if ! echo "$TASK_BLOCK" | grep -q '^\* \*\*Dependencies:'; then
        warning "Task $TASK_ID missing Dependencies field"
    fi
    
    # Check Parent field validity
    if echo "$TASK_BLOCK" | grep -q '^\* \*\*Parent:'; then
        PARENT=$(echo "$TASK_BLOCK" | grep '^\* \*\*Parent:' | sed 's/.*Parent:[[:space:]]*//')
        if [ -n "$PARENT" ] && [ "$PARENT" != "none" ]; then
            if ! echo "$ALL_TASK_IDS" | grep -q "^${PARENT}$"; then
                error "Task $TASK_ID references non-existent parent: $PARENT"
            fi
        fi
    fi
    
    # Check Dependencies validity
    if echo "$TASK_BLOCK" | grep -q '^\* \*\*Dependencies:'; then
        DEPS=$(echo "$TASK_BLOCK" | grep '^\* \*\*Dependencies:' | sed 's/.*Dependencies:[[:space:]]*//')
        if [ -n "$DEPS" ] && [ "$DEPS" != "none" ]; then
            IFS=',' read -ra DEP_ARRAY <<< "$DEPS"
            for dep in "${DEP_ARRAY[@]}"; do
                dep=$(echo "$dep" | xargs)  # Trim whitespace
                if [[ $dep == T-* ]]; then
                    if ! echo "$ALL_TASK_IDS" | grep -q "^${dep}$"; then
                        error "Task $TASK_ID depends on non-existent task: $dep"
                    fi
                elif [[ $dep == Q-* ]]; then
                    # Questions are expected and valid
                    :
                else
                    warning "Task $TASK_ID has unexpected dependency format: $dep"
                fi
            done
        fi
    fi
    
    # Check for issue marker
    if ! echo "$TASK_BLOCK" | head -1 | grep -q '\[Issue #'; then
        error "Task $TASK_ID missing issue marker"
    fi
done

# Check questions.json if it exists
if [ -f ".claude/questions.json" ]; then
    echo -e "\nValidating .claude/questions.json..."
    if ! jq empty .claude/questions.json 2>/dev/null; then
        error "questions.json is not valid JSON"
    else
        success "questions.json is valid JSON"
        
        # Check if any Q-XXX in plan.md exist in questions.json
        QUESTION_REFS=$(grep -oE 'Q-[0-9]+' .claude/plan.md | sort -u)
        if [ -n "$QUESTION_REFS" ]; then
            for Q_ID in $QUESTION_REFS; do
                if ! jq -e ".[\"$Q_ID\"]" .claude/questions.json >/dev/null 2>&1; then
                    warning "Question $Q_ID referenced in plan but not in questions.json"
                fi
            done
        fi
    fi
else
    warning ".claude/questions.json not found"
fi

# Check for required sections
echo -e "\nChecking required sections..."
if ! grep -q '^# Plan (v[0-9.]+)' .claude/plan.md; then
    error "Missing Plan version header"
else
    success "Plan version header found"
fi

if ! grep -q '^\*\*Parent Issue:' .claude/plan.md; then
    error "Missing Parent Issue section"
else
    success "Parent Issue section found"
fi

if ! grep -q '^\*\*Change Log' .claude/plan.md; then
    warning "Missing Change Log section"
fi

if ! grep -q '^\*\*Scope & Deliverables' .claude/plan.md; then
    warning "Missing Scope & Deliverables section"
fi

if ! grep -q '^\*\*Hierarchical TODO' .claude/plan.md; then
    error "Missing Hierarchical TODO (WBS) section"
else
    success "Hierarchical TODO section found"
fi

# Summary
echo "=========================="
if [ $ERRORS -eq 0 ]; then
    if [ $WARNINGS -eq 0 ]; then
        echo -e "${GREEN}✓ Validation passed with no issues!${NC}"
    else
        echo -e "${GREEN}✓ Validation passed with $WARNINGS warnings${NC}"
    fi
    exit 0
else
    echo -e "${RED}✗ Validation failed with $ERRORS errors and $WARNINGS warnings${NC}"
    exit 1
fi